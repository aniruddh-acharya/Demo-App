"use strict";
var TypeORMGenerateHook_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeORMGenerateHook = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@tsed/cli");
const cli_core_1 = require("@tsed/cli-core");
const di_1 = require("@tsed/di");
const change_case_1 = require("change-case");
const templateDir_1 = require("../utils/templateDir");
let TypeORMGenerateHook = TypeORMGenerateHook_1 = class TypeORMGenerateHook {
    providersInfoService;
    projectPackageJson;
    srcRenderService;
    cliDockerComposeYaml;
    constructor(providersInfoService) {
        this.providersInfoService = providersInfoService;
        providersInfoService.add({
            name: "TypeORM Datasource",
            value: "typeorm:datasource",
            model: "{{symbolName}}.datasource"
        }, TypeORMGenerateHook_1);
    }
    async onGeneratePrompt() {
        const list = this.getTypeORMTypes().map(([value, { name }]) => {
            return {
                name: name,
                value: value
            };
        });
        return [
            {
                type: "autocomplete",
                name: "typeormDataSource",
                message: "Which database type?",
                when(state) {
                    return state.type === "typeorm:datasource";
                },
                source: async (state, keyword) => {
                    if (keyword) {
                        return list.filter((item) => item.name.toLowerCase().includes(keyword.toLowerCase()));
                    }
                    return list;
                }
            }
        ];
    }
    onGenerateExec(ctx) {
        if (this.providersInfoService.isMyProvider(ctx.type, TypeORMGenerateHook_1)) {
            return this.generateDataSourceTasks(ctx);
        }
        return [];
    }
    getTypeORMTypes() {
        return Object.entries(cli_1.FeaturesMap).filter(([value]) => value.startsWith("typeorm:"));
    }
    generateDataSourceTasks(ctx) {
        const { typeormDataSource, symbolPath, name } = ctx;
        if (!typeormDataSource) {
            return [];
        }
        this.getTypeORMTypes()
            .filter(([value]) => value === typeormDataSource)
            .forEach(([, feature]) => {
            if (feature.dependencies) {
                this.projectPackageJson.addDependencies(feature.dependencies);
            }
            if (feature.devDependencies) {
                this.projectPackageJson.addDependencies(feature.devDependencies);
            }
        });
        const database = typeormDataSource.split(":").at(-1);
        const symbolName = ctx.symbolName.replace("Datasource", "DataSource");
        return [
            {
                title: `Generate TypeORM datasource file to '${symbolPath}.ts'`,
                task: () => this.srcRenderService.render("datasource.hbs", {
                    name,
                    database,
                    symbolName,
                    tokenName: (0, change_case_1.constantCase)(symbolName)
                }, {
                    templateDir: templateDir_1.TEMPLATE_DIR,
                    output: `${ctx.symbolPath}.ts`,
                    rootDir: this.srcRenderService.rootDir
                })
            },
            {
                title: "Generate docker-compose configuration",
                task: () => this.cliDockerComposeYaml.addDatabaseService(name, database)
            }
        ];
    }
};
tslib_1.__decorate([
    (0, cli_core_1.Inject)(),
    tslib_1.__metadata("design:type", cli_core_1.ProjectPackageJson)
], TypeORMGenerateHook.prototype, "projectPackageJson", void 0);
tslib_1.__decorate([
    (0, cli_core_1.Inject)(),
    tslib_1.__metadata("design:type", cli_core_1.SrcRendererService)
], TypeORMGenerateHook.prototype, "srcRenderService", void 0);
tslib_1.__decorate([
    (0, cli_core_1.Inject)(),
    tslib_1.__metadata("design:type", cli_core_1.CliDockerComposeYaml)
], TypeORMGenerateHook.prototype, "cliDockerComposeYaml", void 0);
tslib_1.__decorate([
    (0, cli_core_1.OnPrompt)("generate"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], TypeORMGenerateHook.prototype, "onGeneratePrompt", null);
tslib_1.__decorate([
    (0, cli_core_1.OnExec)("generate"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Array)
], TypeORMGenerateHook.prototype, "onGenerateExec", null);
TypeORMGenerateHook = TypeORMGenerateHook_1 = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [cli_1.ProvidersInfoService])
], TypeORMGenerateHook);
exports.TypeORMGenerateHook = TypeORMGenerateHook;
//# sourceMappingURL=TypeORMGenerateHook.js.map