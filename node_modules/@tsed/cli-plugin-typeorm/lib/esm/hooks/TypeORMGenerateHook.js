var TypeORMGenerateHook_1;
import { __decorate, __metadata } from "tslib";
import { FeaturesMap, ProvidersInfoService } from "@tsed/cli";
import { CliDockerComposeYaml, Inject, OnExec, OnPrompt, ProjectPackageJson, SrcRendererService } from "@tsed/cli-core";
import { Injectable } from "@tsed/di";
import { constantCase } from "change-case";
import { TEMPLATE_DIR } from "../utils/templateDir.js";
let TypeORMGenerateHook = TypeORMGenerateHook_1 = class TypeORMGenerateHook {
    providersInfoService;
    projectPackageJson;
    srcRenderService;
    cliDockerComposeYaml;
    constructor(providersInfoService) {
        this.providersInfoService = providersInfoService;
        providersInfoService.add({
            name: "TypeORM Datasource",
            value: "typeorm:datasource",
            model: "{{symbolName}}.datasource"
        }, TypeORMGenerateHook_1);
    }
    async onGeneratePrompt() {
        const list = this.getTypeORMTypes().map(([value, { name }]) => {
            return {
                name: name,
                value: value
            };
        });
        return [
            {
                type: "autocomplete",
                name: "typeormDataSource",
                message: "Which database type?",
                when(state) {
                    return state.type === "typeorm:datasource";
                },
                source: async (state, keyword) => {
                    if (keyword) {
                        return list.filter((item) => item.name.toLowerCase().includes(keyword.toLowerCase()));
                    }
                    return list;
                }
            }
        ];
    }
    onGenerateExec(ctx) {
        if (this.providersInfoService.isMyProvider(ctx.type, TypeORMGenerateHook_1)) {
            return this.generateDataSourceTasks(ctx);
        }
        return [];
    }
    getTypeORMTypes() {
        return Object.entries(FeaturesMap).filter(([value]) => value.startsWith("typeorm:"));
    }
    generateDataSourceTasks(ctx) {
        const { typeormDataSource, symbolPath, name } = ctx;
        if (!typeormDataSource) {
            return [];
        }
        this.getTypeORMTypes()
            .filter(([value]) => value === typeormDataSource)
            .forEach(([, feature]) => {
            if (feature.dependencies) {
                this.projectPackageJson.addDependencies(feature.dependencies);
            }
            if (feature.devDependencies) {
                this.projectPackageJson.addDependencies(feature.devDependencies);
            }
        });
        const database = typeormDataSource.split(":").at(-1);
        const symbolName = ctx.symbolName.replace("Datasource", "DataSource");
        return [
            {
                title: `Generate TypeORM datasource file to '${symbolPath}.ts'`,
                task: () => this.srcRenderService.render("datasource.hbs", {
                    name,
                    database,
                    symbolName,
                    tokenName: constantCase(symbolName)
                }, {
                    templateDir: TEMPLATE_DIR,
                    output: `${ctx.symbolPath}.ts`,
                    rootDir: this.srcRenderService.rootDir
                })
            },
            {
                title: "Generate docker-compose configuration",
                task: () => this.cliDockerComposeYaml.addDatabaseService(name, database)
            }
        ];
    }
};
__decorate([
    Inject(),
    __metadata("design:type", ProjectPackageJson)
], TypeORMGenerateHook.prototype, "projectPackageJson", void 0);
__decorate([
    Inject(),
    __metadata("design:type", SrcRendererService)
], TypeORMGenerateHook.prototype, "srcRenderService", void 0);
__decorate([
    Inject(),
    __metadata("design:type", CliDockerComposeYaml)
], TypeORMGenerateHook.prototype, "cliDockerComposeYaml", void 0);
__decorate([
    OnPrompt("generate"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TypeORMGenerateHook.prototype, "onGeneratePrompt", null);
__decorate([
    OnExec("generate"),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], TypeORMGenerateHook.prototype, "onGenerateExec", null);
TypeORMGenerateHook = TypeORMGenerateHook_1 = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [ProvidersInfoService])
], TypeORMGenerateHook);
export { TypeORMGenerateHook };
//# sourceMappingURL=TypeORMGenerateHook.js.map